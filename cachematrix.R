## The following functions, heavily relying on lexical scoping, cache the inverse of a matrix. 
## This, specifically, allows to store that inverse matrix in memory in order to make successive access
## to it quicker. 


## makeCacheMatrix() creates a special list, storing the matrix we want to take the inverse of
## and the inverse itself. The argument is the input matrix.

makeCacheMatrix <- function(x = as.matrix()) {  

  a<-NULL             ## It creates the variable "a" that will store the inverse matrix,  
                      ## or clear it if it was already used in previous executions of cacheSolve.
  
  set<-function(y){   ## The following lines create a new function that allows to store the input matrix;
    x <<- y           ## thanks to the "<<-" assignment, set() has access to the parent environment,
    a <<- NULL        ##  that is the one of makeCacheMatrix. Moreover, it clears the cache again.
  }
  get<-function() x   ## get() gives access to the input matrix x.
  

  
  set_inv<-function(inverse) a<<-inverse ## set_inv() allows to cache the inverse matrix.
  
  get_inv<-function() a                  ## get_inv() gives access to the stored inverse.      
  
  list(set = set, get = get,                   ## This creates a list containing the 4 functions 
       set_inv = set_inv, get_inv = get_inv)   ## created executing makeCacheMatrix().
}

## cacheSolve() needs as argument the object produced by makeCacheMatrix. It checks whether the inverse was
## already computed and stored in the cache: in that case, it simply prints that; if not, it will execute 
## the function solve() on the input matrix, stored in the object x$get(), and store the result in x$get_inv()
## (x$get and x$get_inv being both objects of the list generated by makeCacheMatrix).

cacheSolve <- function(x, ...) {
  a <- x$get_inv()
  if(!is.null(a)){
    message("getting cached data")
    return(a)
  }
  data<-x$get()
  a<-solve(data, ...)
  x$set_inv(a)
  a
}
